import os
import torch
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from torch.utils.data import DataLoader

from configs.config import config
from data.university_of_ottawa_loader import UniversityOfOttawaDataLoader
from preprocess.data_preprocessor import DataPreprocessor
from models.integrated_model import IntegratedFaultDiagnosisModel
from utils.training import train_model
from models.integrated_model import MotorFaultDataset

def setup_seed(seed=42):
    """设置随机种子以确保可重复性"""
    torch.manual_seed(seed)
    np.random.seed(seed)
    torch.cuda.manual_seed_all(seed)
    torch.backends.cudnn.deterministic = True

def visualize_training_progress(train_losses, val_accuracies):
    """可视化训练过程"""
    plt.figure(figsize=(12, 4))
    
    plt.subplot(1, 2, 1)
    plt.plot(train_losses)
    plt.title('训练损失')
    plt.xlabel('轮次')
    plt.ylabel('损失')
    
    plt.subplot(1, 2, 2)
    plt.plot(val_accuracies)
    plt.title('验证准确率')
    plt.xlabel('轮次')
    plt.ylabel('准确率 (%)')
    
    plt.tight_layout()
    plt.savefig('training_progress.png')
    plt.show()

def main():
    # 设置随机种子
    setup_seed()

    # 检查设备
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    print(f"使用设备: {device}")
    
    # 打印GPU信息
    if torch.cuda.is_available():
        print(f"GPU数量: {torch.cuda.device_count()}")
        for i in range(torch.cuda.device_count()):
            print(f"GPU {i}: {torch.cuda.get_device_name(i)}")
            print(f"GPU {i} 内存: {torch.cuda.get_device_properties(i).total_memory / 1024**3:.1f} GB")

    # 数据集根目录 - 请根据您的实际路径修改
    DATA_ROOT = "./data"  # 修改为您的数据目录路径

    # 检查数据目录是否存在
    if not os.path.exists(DATA_ROOT):
        print(f"错误: 数据目录 {DATA_ROOT} 不存在!")
        print("请将 DATA_ROOT 修改为您的实际数据目录路径")
        return

    # 初始化数据加载器
    data_loader = UniversityOfOttawaDataLoader(DATA_ROOT, config)

    # 加载数据集
    try:
        # 加载训练数据
        data_list, labels, metadata = data_loader.load_dataset(
            use_csv=True,  # 使用CSV文件
            conditions=[0, 1]  # 加载空载和负载工况
        )

        # 初始化预处理器
        preprocessor = DataPreprocessor(config)

        # 处理数据集
        processed_acoustic, processed_vibration, processed_labels, processed_metadata = preprocessor.process_dataset(
            data_list, labels, metadata, apply_augmentation=True
        )

        # 数据划分
        X_acoustic = np.array(processed_acoustic)
        X_vibration = np.array(processed_vibration)
        y = np.array(processed_labels)

        # 训练集和验证集划分
        X_train_acoustic, X_val_acoustic, X_train_vibration, X_val_vibration, y_train, y_val = train_test_split(
            X_acoustic, X_vibration, y, test_size=0.2, random_state=42, stratify=y
        )

        # 创建数据集和数据加载器
        train_dataset = MotorFaultDataset(X_train_acoustic, X_train_vibration, y_train)
        val_dataset = MotorFaultDataset(X_val_acoustic, X_val_vibration, y_val)

        train_loader = DataLoader(train_dataset, batch_size=config.BATCH_SIZE, shuffle=True)
        val_loader = DataLoader(val_dataset, batch_size=config.BATCH_SIZE, shuffle=False)

        # 创建模型
        model = IntegratedFaultDiagnosisModel(config).to(device)

        # 训练模型
        train_losses, val_accuracies, best_val_acc = train_model(
            model, train_loader, val_loader, config, device
        )

        print(f"\n训练完成!")
        print(f"最佳验证准确率: {best_val_acc:.2f}%")

        # 可视化训练过程
        visualize_training_progress(train_losses, val_accuracies)

    except Exception as e:
        print(f"数据加载失败: {e}")
        print("请检查数据目录路径和文件格式")

if __name__ == "__main__":
    main()
